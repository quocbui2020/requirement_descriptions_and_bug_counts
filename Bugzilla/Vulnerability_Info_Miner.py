import os
import json
import requests
import pyodbc
import time
from time import strftime, localtime
from datetime import datetime, timezone

# Connection string
conn_str = 'DRIVER={ODBC Driver 18 for SQL Server};' \
           'SERVER=QUOCBUI-PERSONA\\MSSQLSERVER01;' \
           'DATABASE=ResearchDatasets;' \
           'Connection Timeout=300;' \
           'Login Timeout=300;' \
           'LongAsMax=yes;' \
           'TrustServerCertificate=yes;' \
           'Trusted_Connection=yes;'


class Vulnerability_Info_Miner:
    def __init__(self):
        pass

    def cve_scraper(self):
        global conn_str

        ############################################################################################
        # Helper Functions:

        def get_processed_data(): 
            print(f"Getting processed records...", end="", flush=True)

            conn = pyodbc.connect(conn_str)
            cursor = conn.cursor()
            try:
                cursor.execute('''
                SELECT DISTINCT b.alias
                FROM Bugzilla b
                LEFT JOIN [CVE_Vulnerabilities] cve ON cve.CVE_ID = b.alias
                WHERE b.alias LIKE 'CVE%' -- Only include records associated with CVE identifiers.
                    AND cve.CVE_ID IS NULL; -- Ensure to retrieve not yet processed records
                ''')
                rows = cursor.fetchall()
            finally:
                cursor.close()
                conn.close()

            print("Complete")
            return rows
        
        def customized_print(message, end_with_char, clear_console=True):
            if clear_console:
                # Use 'cls' for Windows and 'clear' for Unix-like systems
                os.system('cls' if os.name == 'nt' else 'clear')
            
            print(" " * 80, end="\r")  # Clear the line
            print(f"[{strftime('%m/%d/%Y %H:%M:%S', localtime())}] Remainings: {remaining_record}. {row_cve_id}...{message}", end=f'{end_with_char}', flush=True)

        ############################################################################################
        

        # Get data to process:
        rows = get_processed_data()
        remaining_record = len(rows)
        request_url_template = "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"

        i = 0
        rerun_attempt = 0
        while i < len(rows):
            rerun_attempt += 1
            print_statements = ""
            row_cve_id = rows[i][0]

            print_statements += "Making API request"
            customized_print(print_statements, '\r')

            request_url = request_url_template.format(cve_id=row_cve_id)
            # request_url = "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=CVE-2019-1010218" # This is for testing specific url
            response = requests.get(request_url)

            if response.status_code == 403:
                # If 403, retry again after sleep for some seconds
                if rerun_attempt <= 5:
                    customized_print(f"Status Code: 403. Attempt: {rerun_attempt}/5. Sleeping...", '\r')
                    time.sleep(30)
                    continue
                else:
                    customized_print("Status code: 403", '\n')
            if response.status_code != 200:
                customized_print(f"Status Code (Not 200): {response.status_code}", '')
                return
            
            # Parse the JSON response
            data = response.json()
            vulnerabilities = data.get("vulnerabilities", [])

            for vulnerability in vulnerabilities:
                cve_data = vulnerability.get("cve", {})
                id = cve_data.get("id", "N/A")
                source_identifier = cve_data.get("sourceIdentifier", "N/A")
                published = cve_data.get("published", "N/A")
                last_modified = cve_data.get("lastModified", "N/A")
                vuln_status = cve_data.get("vulnStatus", "N/A")
                descriptions = cve_data.get("descriptions", [])

                # Get English description
                description = next((d["value"] for d in descriptions if d["lang"] == "en"), "N/A")

                # Weaknesses
                weaknesses = vulnerability.get("cve", {}).get("weaknesses", {})
                weakness_values = [w["description"][0]["value"] for w in weaknesses if w.get("description")]

                # CVSS Metrics
                metrics = vulnerability.get("cve", {}).get("metrics", {})
                cvss_metrics = []

                for metric_key, metric_list in metrics.items():
                    for metric in metric_list:
                        cvss_data = metric.get("cvssData", {})
                        base_score = cvss_data.get("baseScore", "N/A")
                        if base_score != "N/A":
                            cvss_metrics.append(f"{base_score}:{metric_key}")

                print_statements += "...Saving database"
                customized_print(print_statements, '\r')

                # Save to database (assuming schema matches)
                conn = pyodbc.connect(conn_str)
                cursor = conn.cursor()

                # Compress the full JSON response (remove spaces to minimize character count)
                compressed_json_response = json.dumps(data).replace(' ', '')

                cursor.execute('''
                INSERT INTO CVE_Vulnerabilities 
                (CVE_ID, CWE_ID, Description, CVSS_Metric_BaseScores, CVE_Published_On, CVE_Last_Modified, CVE_Vuln_Status, Source_Identifier, CVE_API_Response, Inserted_On)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    id,  # CVE_ID
                    ' | '.join(weakness_values) if weakness_values else None,  # CWE_ID
                    description,  # Description
                    ' | '.join(map(str, cvss_metrics)),  # CVSS_Metric_BaseScores
                    published,  # CVE_Published_On
                    last_modified,  # CVE_Last_Modified
                    vuln_status,  # CVE_Vuln_Status
                    source_identifier,  # Source_Identifier
                    compressed_json_response,  # CVE_API_Response
                    datetime.now(timezone.utc)  # Inserted_On
                ))

                conn.commit()
                conn.close()

            print_statements += "...Success...Sleeping"
            customized_print(print_statements, '\r')

            time.sleep(6) # Sleep for 6 seconds to prevent spamming the server.
            remaining_record -= 1
            rerun_attempt = 0
            i += 1



if __name__ == "__main__":
    object = Vulnerability_Info_Miner()
    object.cve_scraper()
